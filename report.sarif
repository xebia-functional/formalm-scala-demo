{
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "version": "2.1.0",
  "runs": [
    {
      "results": [
        {
          "baselineState": "new",
          "fixes": [
            {
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/main/scala/Main.scala"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "startColumn": 151,
                        "startLine": 5
                      },
                      "insertedContent": {
                        "text": ""
                      }
                    }
                  ]
                }
              ],
              "description": {
                "text": "Add tests"
              }
            }
          ],
          "level": "note",
          "locations": [
            {
              "message": {
                "text": ""
              },
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/scala/Main.scala"
                },
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startColumn": 151,
                  "startLine": 5
                }
              }
            }
          ],
          "message": {
            "text": "Test coverage can be improved"
          },
          "ruleId": "a65c443a-f568-4fba-8bd1-acb640debb72"
        },
        {
          "baselineState": "new",
          "fixes": [
            {
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/main/scala/api/Server.scala"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "startColumn": 453,
                        "startLine": 19
                      },
                      "insertedContent": {
                        "text": ""
                      }
                    }
                  ]
                }
              ],
              "description": {
                "text": "Add tests"
              }
            }
          ],
          "level": "note",
          "locations": [
            {
              "message": {
                "text": ""
              },
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/scala/api/Server.scala"
                },
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startColumn": 453,
                  "startLine": 19
                }
              }
            }
          ],
          "message": {
            "text": "Test coverage can be improved"
          },
          "ruleId": "ac4a24d2-9531-4f9c-a64a-d626e0845b83"
        },
        {
          "baselineState": "new",
          "fixes": [
            {
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/main/scala/api/Routes.scala"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "startColumn": 659,
                        "startLine": 21
                      },
                      "insertedContent": {
                        "text": "// 1. Test that the `_routes` function returns an `HttpRoutes` object.\\nval routes = _routes\nassert(routes.isInstanceOf[HttpRoutes[F]])\\n\n// 2. Test that the `_routes` function handles a POST request to the \"/webhook\" endpoint.\\nval request = Request[F](Method.POST, Uri.uri(\"/webhook\"))\nval response = _routes.orNotFound(request).unsafeRunSync()\nassert(response.status == Status.Ok)\\n\n// 3. Test that the `_routes` function returns a 404 response for a GET request to the \"/webhook\" endpoint.\\nval request = Request[F](Method.GET, Uri.uri(\"/webhook\"))\nval response = _routes.orNotFound(request).unsafeRunSync()\nassert(response.status == Status.NotFound)\\n"
                      }
                    }
                  ]
                }
              ],
              "description": {
                "text": "Add tests"
              }
            }
          ],
          "level": "note",
          "locations": [
            {
              "message": {
                "text": "// 1. Test that the `_routes` function returns an `HttpRoutes` object.\\nval routes = _routes\nassert(routes.isInstanceOf[HttpRoutes[F]])\\n\n// 2. Test that the `_routes` function handles a POST request to the \"/webhook\" endpoint.\\nval request = Request[F](Method.POST, Uri.uri(\"/webhook\"))\nval response = _routes.orNotFound(request).unsafeRunSync()\nassert(response.status == Status.Ok)\\n\n// 3. Test that the `_routes` function returns a 404 response for a GET request to the \"/webhook\" endpoint.\\nval request = Request[F](Method.GET, Uri.uri(\"/webhook\"))\nval response = _routes.orNotFound(request).unsafeRunSync()\nassert(response.status == Status.NotFound)\\n"
              },
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/scala/api/Routes.scala"
                },
                "region": {
                  "snippet": {
                    "text": "// 1. Test that the `_routes` function returns an `HttpRoutes` object.\\nval routes = _routes\nassert(routes.isInstanceOf[HttpRoutes[F]])\\n\n// 2. Test that the `_routes` function handles a POST request to the \"/webhook\" endpoint.\\nval request = Request[F](Method.POST, Uri.uri(\"/webhook\"))\nval response = _routes.orNotFound(request).unsafeRunSync()\nassert(response.status == Status.Ok)\\n\n// 3. Test that the `_routes` function returns a 404 response for a GET request to the \"/webhook\" endpoint.\\nval request = Request[F](Method.GET, Uri.uri(\"/webhook\"))\nval response = _routes.orNotFound(request).unsafeRunSync()\nassert(response.status == Status.NotFound)\\n"
                  },
                  "startColumn": 659,
                  "startLine": 21
                }
              }
            }
          ],
          "message": {
            "text": "Test coverage can be improved"
          },
          "ruleId": "8a868d8b-28c6-48d5-a572-b9c6282b4adc"
        },
        {
          "baselineState": "new",
          "fixes": [
            {
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/main/scala/api/Routes.scala"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "startColumn": 732,
                        "startLine": 24
                      },
                      "insertedContent": {
                        "text": "// 1. Test: Ensure that the `routes` method returns an instance of `HttpRoutes[F]`\\n// Code snippet\nval result = routes\nassert(result.isInstanceOf[HttpRoutes[F]])\\n\n// 2. Test: Ensure that the `routes` method calls the `m` function with the `_routes` parameter\\n// Code snippet\nval mockM = mockFunction[HttpRoutes[F], HttpRoutes[F]]\nval mockRoutes = mock[HttpRoutes[F]]\nmockM.expects(mockRoutes).returning(mockRoutes)\n\nval result = routes(mockM)\nverify(mockM).apply(_routes)\\n\n// 3. Test: Ensure that the `routes` method throws an exception if the `m` function returns `null`\\n// Code snippet\nval mockM = mockFunction[HttpRoutes[F], HttpRoutes[F]]\nval mockRoutes = mock[HttpRoutes[F]]\nmockM.expects(mockRoutes).returning(null)\n\nassertThrows[NullPointerException] {\n  routes(mockM)\n}\\n"
                      }
                    }
                  ]
                }
              ],
              "description": {
                "text": "Add tests"
              }
            }
          ],
          "level": "note",
          "locations": [
            {
              "message": {
                "text": "// 1. Test: Ensure that the `routes` method returns an instance of `HttpRoutes[F]`\\n// Code snippet\nval result = routes\nassert(result.isInstanceOf[HttpRoutes[F]])\\n\n// 2. Test: Ensure that the `routes` method calls the `m` function with the `_routes` parameter\\n// Code snippet\nval mockM = mockFunction[HttpRoutes[F], HttpRoutes[F]]\nval mockRoutes = mock[HttpRoutes[F]]\nmockM.expects(mockRoutes).returning(mockRoutes)\n\nval result = routes(mockM)\nverify(mockM).apply(_routes)\\n\n// 3. Test: Ensure that the `routes` method throws an exception if the `m` function returns `null`\\n// Code snippet\nval mockM = mockFunction[HttpRoutes[F], HttpRoutes[F]]\nval mockRoutes = mock[HttpRoutes[F]]\nmockM.expects(mockRoutes).returning(null)\n\nassertThrows[NullPointerException] {\n  routes(mockM)\n}\\n"
              },
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/scala/api/Routes.scala"
                },
                "region": {
                  "snippet": {
                    "text": "// 1. Test: Ensure that the `routes` method returns an instance of `HttpRoutes[F]`\\n// Code snippet\nval result = routes\nassert(result.isInstanceOf[HttpRoutes[F]])\\n\n// 2. Test: Ensure that the `routes` method calls the `m` function with the `_routes` parameter\\n// Code snippet\nval mockM = mockFunction[HttpRoutes[F], HttpRoutes[F]]\nval mockRoutes = mock[HttpRoutes[F]]\nmockM.expects(mockRoutes).returning(mockRoutes)\n\nval result = routes(mockM)\nverify(mockM).apply(_routes)\\n\n// 3. Test: Ensure that the `routes` method throws an exception if the `m` function returns `null`\\n// Code snippet\nval mockM = mockFunction[HttpRoutes[F], HttpRoutes[F]]\nval mockRoutes = mock[HttpRoutes[F]]\nmockM.expects(mockRoutes).returning(null)\n\nassertThrows[NullPointerException] {\n  routes(mockM)\n}\\n"
                  },
                  "startColumn": 732,
                  "startLine": 24
                }
              }
            }
          ],
          "message": {
            "text": "Test coverage can be improved"
          },
          "ruleId": "0472b28f-9bf3-4da3-b4f7-4a613aaa874a"
        },
        {
          "baselineState": "new",
          "fixes": [
            {
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/main/scala/api/Middleware.scala"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "startColumn": 1095,
                        "startLine": 36
                      },
                      "insertedContent": {
                        "text": "// 1. Test that the function returns a Response with status code 500 and the error message when given a Throwable with a message.\\nval throwable = new Throwable(\"Test error message\")\nval response = internalServerError(throwable).unsafeRunSync()\nassert(response.status == Status.InternalServerError)\nassert(response.bodyText == \"Test error message\")\\n\n// 2. Test that the function logs the error message when given a Throwable with a message.\\nval throwable = new Throwable(\"Test error message\")\ninternalServerError(throwable).unsafeRunSync()\nverify(logger).error(\"Test error message\")\\n\n// 3. Test that the function returns a Response with status code 500 and a generic error message when given a Throwable without a message.\\nval throwable = new Throwable()\nval response = internalServerError(throwable).unsafeRunSync()\nassert(response.status == Status.InternalServerError)\nassert(response.bodyText == \"Internal server error\")\\n\n// 4. Test that the function logs a generic error message when given a Throwable without a message.\\nval throwable = new Throwable()\ninternalServerError(throwable).unsafeRunSync()\nverify(logger).error(\"Internal server error\")\\n"
                      }
                    }
                  ]
                }
              ],
              "description": {
                "text": "Add tests"
              }
            }
          ],
          "level": "note",
          "locations": [
            {
              "message": {
                "text": "// 1. Test that the function returns a Response with status code 500 and the error message when given a Throwable with a message.\\nval throwable = new Throwable(\"Test error message\")\nval response = internalServerError(throwable).unsafeRunSync()\nassert(response.status == Status.InternalServerError)\nassert(response.bodyText == \"Test error message\")\\n\n// 2. Test that the function logs the error message when given a Throwable with a message.\\nval throwable = new Throwable(\"Test error message\")\ninternalServerError(throwable).unsafeRunSync()\nverify(logger).error(\"Test error message\")\\n\n// 3. Test that the function returns a Response with status code 500 and a generic error message when given a Throwable without a message.\\nval throwable = new Throwable()\nval response = internalServerError(throwable).unsafeRunSync()\nassert(response.status == Status.InternalServerError)\nassert(response.bodyText == \"Internal server error\")\\n\n// 4. Test that the function logs a generic error message when given a Throwable without a message.\\nval throwable = new Throwable()\ninternalServerError(throwable).unsafeRunSync()\nverify(logger).error(\"Internal server error\")\\n"
              },
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/main/scala/api/Middleware.scala"
                },
                "region": {
                  "snippet": {
                    "text": "// 1. Test that the function returns a Response with status code 500 and the error message when given a Throwable with a message.\\nval throwable = new Throwable(\"Test error message\")\nval response = internalServerError(throwable).unsafeRunSync()\nassert(response.status == Status.InternalServerError)\nassert(response.bodyText == \"Test error message\")\\n\n// 2. Test that the function logs the error message when given a Throwable with a message.\\nval throwable = new Throwable(\"Test error message\")\ninternalServerError(throwable).unsafeRunSync()\nverify(logger).error(\"Test error message\")\\n\n// 3. Test that the function returns a Response with status code 500 and a generic error message when given a Throwable without a message.\\nval throwable = new Throwable()\nval response = internalServerError(throwable).unsafeRunSync()\nassert(response.status == Status.InternalServerError)\nassert(response.bodyText == \"Internal server error\")\\n\n// 4. Test that the function logs a generic error message when given a Throwable without a message.\\nval throwable = new Throwable()\ninternalServerError(throwable).unsafeRunSync()\nverify(logger).error(\"Internal server error\")\\n"
                  },
                  "startColumn": 1095,
                  "startLine": 36
                }
              }
            }
          ],
          "message": {
            "text": "Test coverage can be improved"
          },
          "ruleId": "e8699121-672a-4c2b-8f7b-64568ba63afc"
        },
        {
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "events/src/main/scala/github/GitHubService.scala"
                },
                "region": {
                  "snippet": {
                    "text": "case false if res.status.code == 422 =>"
                  },
                  "startColumn": 45,
                  "startLine": 56
                }
              }
            }
          ],
          "message": {
            "text": "Use === instead of =="
          },
          "ruleId": "6f47349c-c0c6-4977-afff-8a2e384a8214"
        },
        {
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "events/src/main/scala/github/GitHubService.scala"
                },
                "region": {
                  "snippet": {
                    "text": "case false if res.status.code == 404 =>"
                  },
                  "startColumn": 45,
                  "startLine": 79
                }
              }
            }
          ],
          "message": {
            "text": "Use === instead of =="
          },
          "ruleId": "f5edd520-7b69-4ee5-b3a6-54e666f5f535"
        },
        {
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "events/src/main/scala/github/GitHubService.scala"
                },
                "region": {
                  "startColumn": 45,
                  "startLine": 56
                }
              }
            }
          ],
          "message": {
            "text": "use === instead of =="
          },
          "ruleId": "DisableSyntaxNoUniversalEquality"
        }
      ],
      "tool": {
        "driver": {
          "fullName": "Formalm",
          "language": "en",
          "name": "Formalm",
          "organization": "Xebia Functional",
          "rules": [
            {
              "help": {
                "markdown": "",
                "text": "Test coverage can be improved"
              },
              "id": "a65c443a-f568-4fba-8bd1-acb640debb72",
              "name": "Test coverage can be improved",
              "shortDescription": {
                "text": "Coverage report can be improved"
              }
            },
            {
              "help": {
                "markdown": "",
                "text": "Test coverage can be improved"
              },
              "id": "ac4a24d2-9531-4f9c-a64a-d626e0845b83",
              "name": "Test coverage can be improved",
              "shortDescription": {
                "text": "Coverage report can be improved"
              }
            },
            {
              "help": {
                "markdown": "\\n1. Test that the `_routes` function returns an `HttpRoutes` object.\\n```scala\\nval routes = _routes\nassert(routes.isInstanceOf[HttpRoutes[F]])\\n```\n\\n2. Test that the `_routes` function handles a POST request to the \"/webhook\" endpoint.\\n```scala\\nval request = Request[F](Method.POST, Uri.uri(\"/webhook\"))\nval response = _routes.orNotFound(request).unsafeRunSync()\nassert(response.status == Status.Ok)\\n```\n\\n3. Test that the `_routes` function returns a 404 response for a GET request to the \"/webhook\" endpoint.\\n```scala\\nval request = Request[F](Method.GET, Uri.uri(\"/webhook\"))\nval response = _routes.orNotFound(request).unsafeRunSync()\nassert(response.status == Status.NotFound)\\n```",
                "text": "Test coverage can be improved"
              },
              "id": "8a868d8b-28c6-48d5-a572-b9c6282b4adc",
              "name": "Test coverage can be improved",
              "shortDescription": {
                "text": "Coverage report can be improved"
              }
            },
            {
              "help": {
                "markdown": "\\n1. Test: Ensure that the `routes` method returns an instance of `HttpRoutes[F]`\\n```scala\\n// Code snippet\nval result = routes\nassert(result.isInstanceOf[HttpRoutes[F]])\\n```\n\\n2. Test: Ensure that the `routes` method calls the `m` function with the `_routes` parameter\\n```scala\\n// Code snippet\nval mockM = mockFunction[HttpRoutes[F], HttpRoutes[F]]\nval mockRoutes = mock[HttpRoutes[F]]\nmockM.expects(mockRoutes).returning(mockRoutes)\n\nval result = routes(mockM)\nverify(mockM).apply(_routes)\\n```\n\\n3. Test: Ensure that the `routes` method throws an exception if the `m` function returns `null`\\n```scala\\n// Code snippet\nval mockM = mockFunction[HttpRoutes[F], HttpRoutes[F]]\nval mockRoutes = mock[HttpRoutes[F]]\nmockM.expects(mockRoutes).returning(null)\n\nassertThrows[NullPointerException] {\n  routes(mockM)\n}\\n```",
                "text": "Test coverage can be improved"
              },
              "id": "0472b28f-9bf3-4da3-b4f7-4a613aaa874a",
              "name": "Test coverage can be improved",
              "shortDescription": {
                "text": "Coverage report can be improved"
              }
            },
            {
              "help": {
                "markdown": "\\n1. Test that the function returns a Response with status code 500 and the error message when given a Throwable with a message.\\n```scala\\nval throwable = new Throwable(\"Test error message\")\nval response = internalServerError(throwable).unsafeRunSync()\nassert(response.status == Status.InternalServerError)\nassert(response.bodyText == \"Test error message\")\\n```\n\\n2. Test that the function logs the error message when given a Throwable with a message.\\n```scala\\nval throwable = new Throwable(\"Test error message\")\ninternalServerError(throwable).unsafeRunSync()\nverify(logger).error(\"Test error message\")\\n```\n\\n3. Test that the function returns a Response with status code 500 and a generic error message when given a Throwable without a message.\\n```scala\\nval throwable = new Throwable()\nval response = internalServerError(throwable).unsafeRunSync()\nassert(response.status == Status.InternalServerError)\nassert(response.bodyText == \"Internal server error\")\\n```\n\\n4. Test that the function logs a generic error message when given a Throwable without a message.\\n```scala\\nval throwable = new Throwable()\ninternalServerError(throwable).unsafeRunSync()\nverify(logger).error(\"Internal server error\")\\n```",
                "text": "Test coverage can be improved"
              },
              "id": "e8699121-672a-4c2b-8f7b-64568ba63afc",
              "name": "Test coverage can be improved",
              "shortDescription": {
                "text": "Coverage report can be improved"
              }
            },
            {
              "help": {
                "markdown": "### Explanation\nIn Scala, == is used for value comparison while === is used for reference comparison. In this case, we need to use === to compare the status code with 422.\n\n### Fixed code\n```scala\ncase false if res.status.code === 422 =>\n```",
                "text": "In Scala, == is used for value comparison while === is used for reference comparison. In this case, we need to use === to compare the status code with 422."
              },
              "id": "6f47349c-c0c6-4977-afff-8a2e384a8214",
              "name": "Error in file events/src/main/scala/github/GitHubService.scala",
              "shortDescription": {
                "text": "Use === instead of =="
              }
            },
            {
              "help": {
                "markdown": "### Explanation\nIn Scala, == is used for value comparison while === is used for reference comparison. In this case, we need to use === to compare the status code with 404.\n\n### Fixed code\n```scala\ncase false if res.status.code === 404 =>\n```",
                "text": "In Scala, == is used for value comparison while === is used for reference comparison. In this case, we need to use === to compare the status code with 404."
              },
              "id": "f5edd520-7b69-4ee5-b3a6-54e666f5f535",
              "name": "Error in file events/src/main/scala/github/GitHubService.scala",
              "shortDescription": {
                "text": "Use === instead of =="
              }
            },
            {
              "help": {
                "markdown": "### Why this is a problem\nUsing == instead of === in Scala codebases can lead to unexpected behavior due to the difference in type checking. == checks for value equality while === checks for both value and type equality.\n\n### General pattern to fix this class of problems\nReplace all instances of == with === in the codebase.\n\nThis is an example of code with this problem:\n\n```scala\nif (x == 1) { ... }\n```\n\nand this is how is looks after the fix is applied:\n\n```scala\nif (x === 1) { ... }\n```\n\n### How to avoid this problem in the future\nAlways use === instead of == when checking for equality in Scala codebases.",
                "text": "Why this is a problem: Using == instead of === in Scala codebases can lead to unexpected behavior due to the difference in type checking. == checks for value equality while === checks for both value and type equality.\nGeneral pattern to fix: Replace all instances of == with === in the codebase.\nHow to avoid in the future: Always use === instead of == when checking for equality in Scala codebases."
              },
              "id": "DisableSyntaxNoUniversalEquality",
              "name": "Error in file events/src/main/scala/github/GitHubService.scala",
              "shortDescription": {
                "text": "use === instead of =="
              }
            }
          ],
          "version": "0.0.1"
        }
      }
    }
  ]
}
